// @floating-ui/core@1.6.8 downloaded from https://ga.jspm.io/npm:@floating-ui/core@1.6.8/dist/floating-ui.core.mjs

import{getSideAxis as t,getAlignmentAxis as e,getAxisLength as n,getSide as o,getAlignment as s,evaluate as i,getPaddingObject as c,rectToClientRect as r,min as l,clamp as a,getOppositeAlignmentPlacement as f,placements as m,getAlignmentSides as d,getOppositePlacement as u,getExpandedPlacements as g,getOppositeAxisPlacements as p,sides as h,max as y,getOppositeAxis as w}from"@floating-ui/utils";export{rectToClientRect}from"@floating-ui/utils";function computeCoordsFromPlacement(i,c,r){let{reference:l,floating:a}=i;const f=t(c);const m=e(c);const d=n(m);const u=o(c);const g=f==="y";const p=l.x+l.width/2-a.width/2;const h=l.y+l.height/2-a.height/2;const y=l[d]/2-a[d]/2;let w;switch(u){case"top":w={x:p,y:l.y-a.height};break;case"bottom":w={x:p,y:l.y+l.height};break;case"right":w={x:l.x+l.width,y:h};break;case"left":w={x:l.x-a.width,y:h};break;default:w={x:l.x,y:l.y}}switch(s(c)){case"start":w[m]-=y*(r&&g?-1:1);break;case"end":w[m]+=y*(r&&g?-1:1);break}return w}const computePosition=async(t,e,n)=>{const{placement:o="bottom",strategy:s="absolute",middleware:i=[],platform:c}=n;const r=i.filter(Boolean);const l=await(c.isRTL==null?void 0:c.isRTL(e));let a=await c.getElementRects({reference:t,floating:e,strategy:s});let{x:f,y:m}=computeCoordsFromPlacement(a,o,l);let d=o;let u={};let g=0;for(let n=0;n<r.length;n++){const{name:i,fn:p}=r[n];const{x:h,y:y,data:w,reset:x}=await p({x:f,y:m,initialPlacement:o,placement:d,strategy:s,middlewareData:u,rects:a,platform:c,elements:{reference:t,floating:e}});f=h!=null?h:f;m=y!=null?y:m;u={...u,[i]:{...u[i],...w}};if(x&&g<=50){g++;if(typeof x==="object"){x.placement&&(d=x.placement);x.rects&&(a=x.rects===true?await c.getElementRects({reference:t,floating:e,strategy:s}):x.rects);({x:f,y:m}=computeCoordsFromPlacement(a,d,l))}n=-1}}return{x:f,y:m,placement:d,strategy:s,middlewareData:u}};async function detectOverflow(t,e){var n;e===void 0&&(e={});const{x:o,y:s,platform:l,rects:a,elements:f,strategy:m}=t;const{boundary:d="clippingAncestors",rootBoundary:u="viewport",elementContext:g="floating",altBoundary:p=false,padding:h=0}=i(e,t);const y=c(h);const w=g==="floating"?"reference":"floating";const x=f[p?w:g];const v=r(await l.getClippingRect({element:(n=await(l.isElement==null?void 0:l.isElement(x)))==null||n?x:x.contextElement||await(l.getDocumentElement==null?void 0:l.getDocumentElement(f.floating)),boundary:d,rootBoundary:u,strategy:m}));const b=g==="floating"?{x:o,y:s,width:a.floating.width,height:a.floating.height}:a.reference;const A=await(l.getOffsetParent==null?void 0:l.getOffsetParent(f.floating));const R=await(l.isElement==null?void 0:l.isElement(A))&&await(l.getScale==null?void 0:l.getScale(A))||{x:1,y:1};const O=r(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:b,offsetParent:A,strategy:m}):b);return{top:(v.top-O.top+y.top)/R.y,bottom:(O.bottom-v.bottom+y.bottom)/R.y,left:(v.left-O.left+y.left)/R.x,right:(O.right-v.right+y.right)/R.x}}const arrow=t=>({name:"arrow",options:t,async fn(o){const{x:r,y:f,placement:m,rects:d,platform:u,elements:g,middlewareData:p}=o;const{element:h,padding:y=0}=i(t,o)||{};if(h==null)return{};const w=c(y);const x={x:r,y:f};const v=e(m);const b=n(v);const A=await u.getDimensions(h);const R=v==="y";const O=R?"top":"left";const P=R?"bottom":"right";const C=R?"clientHeight":"clientWidth";const D=d.reference[b]+d.reference[v]-x[v]-d.floating[b];const T=x[v]-d.reference[v];const L=await(u.getOffsetParent==null?void 0:u.getOffsetParent(h));let B=L?L[C]:0;B&&await(u.isElement==null?void 0:u.isElement(L))||(B=g.floating[C]||d.floating[b]);const E=D/2-T/2;const k=B/2-A[b]/2-1;const S=l(w[O],k);const F=l(w[P],k);const H=S;const V=B-A[b]-F;const W=B/2-A[b]/2+E;const j=a(H,W,V);const z=!p.arrow&&s(m)!=null&&W!==j&&d.reference[b]/2-(W<H?S:F)-A[b]/2<0;const q=z?W<H?W-H:W-V:0;return{[v]:x[v]+q,data:{[v]:j,centerOffset:W-j-q,...z&&{alignmentOffset:q}},reset:z}}});function getPlacementList(t,e,n){const i=t?[...n.filter((e=>s(e)===t)),...n.filter((e=>s(e)!==t))]:n.filter((t=>o(t)===t));return i.filter((n=>!t||(s(n)===t||!!e&&f(n)!==n)))}const autoPlacement=function(t){t===void 0&&(t={});return{name:"autoPlacement",options:t,async fn(e){var n,c,r;const{rects:l,middlewareData:a,placement:f,platform:u,elements:g}=e;const{crossAxis:p=false,alignment:h,allowedPlacements:y=m,autoAlignment:w=true,...x}=i(t,e);const v=h!==void 0||y===m?getPlacementList(h||null,w,y):y;const b=await detectOverflow(e,x);const A=((n=a.autoPlacement)==null?void 0:n.index)||0;const R=v[A];if(R==null)return{};const O=d(R,l,await(u.isRTL==null?void 0:u.isRTL(g.floating)));if(f!==R)return{reset:{placement:v[0]}};const P=[b[o(R)],b[O[0]],b[O[1]]];const C=[...((c=a.autoPlacement)==null?void 0:c.overflows)||[],{placement:R,overflows:P}];const D=v[A+1];if(D)return{data:{index:A+1,overflows:C},reset:{placement:D}};const T=C.map((t=>{const e=s(t.placement);return[t.placement,e&&p?t.overflows.slice(0,2).reduce(((t,e)=>t+e),0):t.overflows[0],t.overflows]})).sort(((t,e)=>t[1]-e[1]));const L=T.filter((t=>t[2].slice(0,s(t[0])?2:3).every((t=>t<=0))));const B=((r=L[0])==null?void 0:r[0])||T[0][0];return B!==f?{data:{index:A+1,overflows:C},reset:{placement:B}}:{}}}};const flip=function(e){e===void 0&&(e={});return{name:"flip",options:e,async fn(n){var s,c;const{placement:r,middlewareData:l,rects:a,initialPlacement:f,platform:m,elements:h}=n;const{mainAxis:y=true,crossAxis:w=true,fallbackPlacements:x,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:b="none",flipAlignment:A=true,...R}=i(e,n);if((s=l.arrow)!=null&&s.alignmentOffset)return{};const O=o(r);const P=t(f);const C=o(f)===f;const D=await(m.isRTL==null?void 0:m.isRTL(h.floating));const T=x||(C||!A?[u(f)]:g(f));const L=b!=="none";!x&&L&&T.push(...p(f,A,b,D));const B=[f,...T];const E=await detectOverflow(n,R);const k=[];let S=((c=l.flip)==null?void 0:c.overflows)||[];y&&k.push(E[O]);if(w){const t=d(r,a,D);k.push(E[t[0]],E[t[1]])}S=[...S,{placement:r,overflows:k}];if(!k.every((t=>t<=0))){var F,H;const e=(((F=l.flip)==null?void 0:F.index)||0)+1;const n=B[e];if(n)return{data:{index:e,overflows:S},reset:{placement:n}};let o=(H=S.filter((t=>t.overflows[0]<=0)).sort(((t,e)=>t.overflows[1]-e.overflows[1]))[0])==null?void 0:H.placement;if(!o)switch(v){case"bestFit":{var V;const e=(V=S.filter((e=>{if(L){const n=t(e.placement);return n===P||n==="y"}return true})).map((t=>[t.placement,t.overflows.filter((t=>t>0)).reduce(((t,e)=>t+e),0)])).sort(((t,e)=>t[1]-e[1]))[0])==null?void 0:V[0];e&&(o=e);break}case"initialPlacement":o=f;break}if(r!==o)return{reset:{placement:o}}}return{}}}};function getSideOffsets(t,e){return{top:t.top-e.height,right:t.right-e.width,bottom:t.bottom-e.height,left:t.left-e.width}}function isAnySideFullyClipped(t){return h.some((e=>t[e]>=0))}const hide=function(t){t===void 0&&(t={});return{name:"hide",options:t,async fn(e){const{rects:n}=e;const{strategy:o="referenceHidden",...s}=i(t,e);switch(o){case"referenceHidden":{const t=await detectOverflow(e,{...s,elementContext:"reference"});const o=getSideOffsets(t,n.reference);return{data:{referenceHiddenOffsets:o,referenceHidden:isAnySideFullyClipped(o)}}}case"escaped":{const t=await detectOverflow(e,{...s,altBoundary:true});const o=getSideOffsets(t,n.floating);return{data:{escapedOffsets:o,escaped:isAnySideFullyClipped(o)}}}default:return{}}}}};function getBoundingRect(t){const e=l(...t.map((t=>t.left)));const n=l(...t.map((t=>t.top)));const o=y(...t.map((t=>t.right)));const s=y(...t.map((t=>t.bottom)));return{x:e,y:n,width:o-e,height:s-n}}function getRectsByLine(t){const e=t.slice().sort(((t,e)=>t.y-e.y));const n=[];let o=null;for(let t=0;t<e.length;t++){const s=e[t];!o||s.y-o.y>o.height/2?n.push([s]):n[n.length-1].push(s);o=s}return n.map((t=>r(getBoundingRect(t))))}const inline=function(e){e===void 0&&(e={});return{name:"inline",options:e,async fn(n){const{placement:s,elements:a,rects:f,platform:m,strategy:d}=n;const{padding:u=2,x:g,y:p}=i(e,n);const h=Array.from(await(m.getClientRects==null?void 0:m.getClientRects(a.reference))||[]);const w=getRectsByLine(h);const x=r(getBoundingRect(h));const v=c(u);function getBoundingClientRect(){if(w.length===2&&w[0].left>w[1].right&&g!=null&&p!=null)return w.find((t=>g>t.left-v.left&&g<t.right+v.right&&p>t.top-v.top&&p<t.bottom+v.bottom))||x;if(w.length>=2){if(t(s)==="y"){const t=w[0];const e=w[w.length-1];const n=o(s)==="top";const i=t.top;const c=e.bottom;const r=n?t.left:e.left;const l=n?t.right:e.right;const a=l-r;const f=c-i;return{top:i,bottom:c,left:r,right:l,width:a,height:f,x:r,y:i}}const e=o(s)==="left";const n=y(...w.map((t=>t.right)));const i=l(...w.map((t=>t.left)));const c=w.filter((t=>e?t.left===i:t.right===n));const r=c[0].top;const a=c[c.length-1].bottom;const f=i;const m=n;const d=m-f;const u=a-r;return{top:r,bottom:a,left:f,right:m,width:d,height:u,x:f,y:r}}return x}const b=await m.getElementRects({reference:{getBoundingClientRect:getBoundingClientRect},floating:a.floating,strategy:d});return f.reference.x!==b.reference.x||f.reference.y!==b.reference.y||f.reference.width!==b.reference.width||f.reference.height!==b.reference.height?{reset:{rects:b}}:{}}}};async function convertValueToCoords(e,n){const{placement:c,platform:r,elements:l}=e;const a=await(r.isRTL==null?void 0:r.isRTL(l.floating));const f=o(c);const m=s(c);const d=t(c)==="y";const u=["left","top"].includes(f)?-1:1;const g=a&&d?-1:1;const p=i(n,e);let{mainAxis:h,crossAxis:y,alignmentAxis:w}=typeof p==="number"?{mainAxis:p,crossAxis:0,alignmentAxis:null}:{mainAxis:p.mainAxis||0,crossAxis:p.crossAxis||0,alignmentAxis:p.alignmentAxis};m&&typeof w==="number"&&(y=m==="end"?w*-1:w);return d?{x:y*g,y:h*u}:{x:h*u,y:y*g}}const offset=function(t){t===void 0&&(t=0);return{name:"offset",options:t,async fn(e){var n,o;const{x:s,y:i,placement:c,middlewareData:r}=e;const l=await convertValueToCoords(e,t);return c===((n=r.offset)==null?void 0:n.placement)&&(o=r.arrow)!=null&&o.alignmentOffset?{}:{x:s+l.x,y:i+l.y,data:{...l,placement:c}}}}};const shift=function(e){e===void 0&&(e={});return{name:"shift",options:e,async fn(n){const{x:s,y:c,placement:r}=n;const{mainAxis:l=true,crossAxis:f=false,limiter:m={fn:t=>{let{x:e,y:n}=t;return{x:e,y:n}}},...d}=i(e,n);const u={x:s,y:c};const g=await detectOverflow(n,d);const p=t(o(r));const h=w(p);let y=u[h];let x=u[p];if(l){const t=h==="y"?"top":"left";const e=h==="y"?"bottom":"right";const n=y+g[t];const o=y-g[e];y=a(n,y,o)}if(f){const t=p==="y"?"top":"left";const e=p==="y"?"bottom":"right";const n=x+g[t];const o=x-g[e];x=a(n,x,o)}const v=m.fn({...n,[h]:y,[p]:x});return{...v,data:{x:v.x-s,y:v.y-c,enabled:{[h]:l,[p]:f}}}}}};const limitShift=function(e){e===void 0&&(e={});return{options:e,fn(n){const{x:s,y:c,placement:r,rects:l,middlewareData:a}=n;const{offset:f=0,mainAxis:m=true,crossAxis:d=true}=i(e,n);const u={x:s,y:c};const g=t(r);const p=w(g);let h=u[p];let y=u[g];const x=i(f,n);const v=typeof x==="number"?{mainAxis:x,crossAxis:0}:{mainAxis:0,crossAxis:0,...x};if(m){const t=p==="y"?"height":"width";const e=l.reference[p]-l.floating[t]+v.mainAxis;const n=l.reference[p]+l.reference[t]-v.mainAxis;h<e?h=e:h>n&&(h=n)}if(d){var b,A;const t=p==="y"?"width":"height";const e=["top","left"].includes(o(r));const n=l.reference[g]-l.floating[t]+(e&&((b=a.offset)==null?void 0:b[g])||0)+(e?0:v.crossAxis);const s=l.reference[g]+l.reference[t]+(e?0:((A=a.offset)==null?void 0:A[g])||0)-(e?v.crossAxis:0);y<n?y=n:y>s&&(y=s)}return{[p]:h,[g]:y}}}};const size=function(e){e===void 0&&(e={});return{name:"size",options:e,async fn(n){var c,r;const{placement:a,rects:f,platform:m,elements:d}=n;const{apply:u=(()=>{}),...g}=i(e,n);const p=await detectOverflow(n,g);const h=o(a);const w=s(a);const x=t(a)==="y";const{width:v,height:b}=f.floating;let A;let R;if(h==="top"||h==="bottom"){A=h;R=w===(await(m.isRTL==null?void 0:m.isRTL(d.floating))?"start":"end")?"left":"right"}else{R=h;A=w==="end"?"top":"bottom"}const O=b-p.top-p.bottom;const P=v-p.left-p.right;const C=l(b-p[A],O);const D=l(v-p[R],P);const T=!n.middlewareData.shift;let L=C;let B=D;(c=n.middlewareData.shift)!=null&&c.enabled.x&&(B=P);(r=n.middlewareData.shift)!=null&&r.enabled.y&&(L=O);if(T&&!w){const t=y(p.left,0);const e=y(p.right,0);const n=y(p.top,0);const o=y(p.bottom,0);x?B=v-2*(t!==0||e!==0?t+e:y(p.left,p.right)):L=b-2*(n!==0||o!==0?n+o:y(p.top,p.bottom))}await u({...n,availableWidth:B,availableHeight:L});const E=await m.getDimensions(d.floating);return v!==E.width||b!==E.height?{reset:{rects:true}}:{}}}};export{arrow,autoPlacement,computePosition,detectOverflow,flip,hide,inline,limitShift,offset,shift,size};

